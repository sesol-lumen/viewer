<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>킴스 Excel 웹 뷰어</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- SheetJS (XLSX) CDN -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <style>
    :root { --maxw: 1100px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; color:#111; }
    .wrap { max-width: var(--maxw); margin: 0 auto; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    .bar { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    input[type="file"] { border:1px solid #ddd; padding:8px; border-radius:8px; background:#fafafa; }
    .dropzone {
      border:2px dashed #bbb; border-radius:12px; padding:16px; text-align:center; color:#666; cursor:pointer; flex:1; min-width:260px;
    }
    .dropzone.drag { border-color:#666; background:#f6f6f6; }
    .search { flex:1; min-width:240px; padding:10px 12px; border:1px solid #ddd; border-radius:10px; }
    .table-wrap { overflow:auto; border:1px solid #eee; border-radius:12px; }
    table { border-collapse: collapse; width: 100%; font-size:14px; }
    thead th {
      position: sticky; top: 0; background:#fff; border-bottom:1px solid #eee; text-align:left; padding:10px;
      cursor:pointer; user-select:none; white-space:nowrap;
    }
    tbody td { border-bottom:1px solid #f3f3f3; padding:8px 10px; }
    tbody tr:nth-child(even) td { background:#fcfcfc; }
    .muted { color:#888; font-size:12px; }
    .error { color:#b00020; font-size:13px; }
    .hidden { display:none; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>킴스 Excel 웹 뷰어</h1>

  <div class="bar">
    <input id="file" type="file" accept=".xlsx,.xls,.csv" />
    <div id="drop" class="dropzone" title="클릭하거나 파일을 드래그해 업로드">
      여기에 파일을 드래그/드롭하거나 클릭하여 선택하세요
    </div>
    <input id="q" class="search" placeholder="검색어(약품명/바코드/제조사 등) 입력" />
  </div>

  <div id="msg" class="muted">• 읽기 전용 · 브라우저 내 처리 · 데이터는 업로드 시에만 메모리에서 사용됩니다</div>
  <div id="err" class="error hidden"></div>
  <div id="meta" class="muted"></div>

  <div class="table-wrap" aria-live="polite">
    <table id="grid">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
  const $ = sel => document.querySelector(sel);
  const grid = $("#grid");
  const thead = grid.querySelector("thead");
  const tbody = grid.querySelector("tbody");
  const q = $("#q");
  const fileInput = $("#file");
  const drop = $("#drop");
  const err = $("#err");
  const meta = $("#meta");

  const state = {
    headers: [],
    rows: [],
    filtered: [],
    sort: { col: -1, dir: 1 },
  };

  function safeText(v) {
    // SheetJS에서 raw:false로 포맷 적용된 문자열을 최대한 그대로 사용
    // undefined/null 방지 + 문자열화
    return (v === undefined || v === null) ? "" : String(v);
  }

  function detectHeaderRow(arr2d) {
    // "빈 셀 제외 2개 이상 값"이 있는 첫 행을 헤더로 간주 (엑셀 상단에 설명행 있을 수 있음)
    for (let i = 0; i < arr2d.length; i++) {
      const nonEmpty = (arr2d[i] || []).filter(v => safeText(v).trim() !== "");
      if (nonEmpty.length >= 2) return i;
    }
    return 0;
  }

  function toRows(sheet) {
    // raw:false => 서식 적용된 텍스트 사용 (바코드 0 유실/과학표기 최소화)
    const arr2d = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "", raw: false });
    if (!arr2d.length) return { headers: [], rows: [] };
    const hIdx = detectHeaderRow(arr2d);
    const rawHeaders = (arr2d[hIdx] || []).map(safeText);
    const headers = rawHeaders.map((h, i) => {
      const name = h.trim();
      return name || `Column${i+1}`;
    });

    const dataRows = arr2d.slice(hIdx + 1).map(r => {
      const row = headers.map((_, i) => safeText(r[i]));
      // 전부 빈칸인 행은 제외
      return row.every(c => c.trim() === "") ? null : row;
    }).filter(Boolean);

    return { headers, rows: dataRows };
  }

  function renderTable() {
    // 헤더
    thead.innerHTML = "";
    const tr = document.createElement("tr");
    state.headers.forEach((h, i) => {
      const th = document.createElement("th");
      th.textContent = h + (state.sort.col === i ? (state.sort.dir === 1 ? " ▲" : " ▼") : "");
      th.title = "클릭하여 정렬";
      th.addEventListener("click", () => sortBy(i));
      tr.appendChild(th);
    });
    thead.appendChild(tr);

    // 바디
    tbody.innerHTML = "";
    const showing = (state.filtered.length ? state.filtered : state.rows);
    showing.forEach(row => {
      const tr = document.createElement("tr");
      row.forEach(cell => {
        const td = document.createElement("td");
        td.textContent = cell;
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });

    // 메타
    const total = state.rows.length;
    const shown = showing.length;
    meta.textContent = total ? `표시: ${shown.toLocaleString()} / 전체: ${total.toLocaleString()} 행` : "";
  }

  function sortBy(col) {
    const dir = (state.sort.col === col) ? -state.sort.dir : 1;
    state.sort = { col, dir };
    const target = (state.filtered.length ? state.filtered : state.rows);

    // 숫자/문자 혼합 안정 정렬 (바코드는 문자열 비교가 일반적이라 숫자 변환을 강제하지 않음)
    target.sort((a, b) => {
      const av = a[col] ?? "";
      const bv = b[col] ?? "";
      // 숫자처럼 보이고 길이가 짧은 일반 수치형만 숫자 비교 (바코드 같은 장문 숫자열은 문자열 비교)
      const numLike = v => /^[\s\-+]?\d{1,15}([.,]\d+)?\s*$/.test(v); // 과도하게 긴 숫자는 제외
      if (numLike(av) && numLike(bv)) {
        const an = parseFloat(String(av).replace(/,/g, ""));
        const bn = parseFloat(String(bv).replace(/,/g, ""));
        if (!Number.isNaN(an) && !Number.isNaN(bn)) return (an - bn) * dir;
      }
      return String(av).localeCompare(String(bv), "ko", { numeric: true }) * dir;
    });
    renderTable();
  }

  function applySearch() {
    const key = q.value.trim();
    if (!key) { state.filtered = []; return renderTable(); }
    const lower = key.toLowerCase();
    state.filtered = state.rows.filter(r =>
      r.some(c => String(c).toLowerCase().includes(lower))
    );
    renderTable();
  }

  q.addEventListener("input", applySearch);

  async function handleFile(file) {
    clearError();
    if (!file) return;
    const okExt = /\.(xlsx|xls|csv)$/i.test(file.name);
    if (!okExt) return showError("엑셀(.xlsx/.xls) 또는 CSV 파일만 업로드할 수 있습니다.");

    try {
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type: "array" });
      if (!wb.SheetNames || !wb.SheetNames.length) {
        return showError("시트를 찾을 수 없습니다. 파일 내용을 확인해주세요.");
      }
      const first = wb.Sheets[wb.SheetNames[0]];
      const { headers, rows } = toRows(first);
      if (!headers.length) return showError("헤더(첫 행)를 인식하지 못했습니다. 파일 상단의 빈 줄/설명 줄을 제거해보세요.");
      state.headers = headers;
      state.rows = rows;
      state.filtered = [];
      state.sort = { col: -1, dir: 1 };
      renderTable();
      if (!rows.length) showError("표시할 데이터 행이 없습니다.");
    } catch (e) {
      console.error(e);
      showError("파일을 열 수 없습니다. 손상된 파일이거나 지원되지 않는 형식일 수 있습니다.");
    }
  }

  function showError(message) {
    err.textContent = message;
    err.classList.remove("hidden");
  }
  function clearError() {
    err.textContent = "";
    err.classList.add("hidden");
  }

  // 파일 입력
  fileInput.addEventListener("change", e => handleFile(e.target.files[0]));

  // 드래그앤드롭
  ["dragenter","dragover"].forEach(ev =>
    drop.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); drop.classList.add("drag"); })
  );
  ;["dragleave","dragend"].forEach(ev =>
    drop.addEventListener(ev, () => drop.classList.remove("drag"))
  );
  drop.addEventListener("drop", e => {
    e.preventDefault(); e.stopPropagation(); drop.classList.remove("drag");
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    handleFile(f);
  });
  drop.addEventListener("click", () => fileInput.click());
</script>
</body>
</html>
